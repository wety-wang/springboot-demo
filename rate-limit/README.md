# springboot-rate-limit

## 什么是限流？

> 维基百科的概念如下：
>
> In computer networks, rate limiting is used to control the rate of requests sent or received by a network interface controller. It can be used to prevent DoS attacks and limit web scraping

通俗来讲就限流就是是对某一时间窗口内的请求数进行限制，保持系统的可用性和稳定性，防止因流量暴增而导致的系统运行缓慢或宕机。

## 为什么要进行限流？

因为互联网系统通常都要面对大并发大流量的请求，在突发情况下（最常见的场景就是秒杀、抢购），瞬时大流量会直接将系统打垮，无法对外提供服务。那为了防止出现这种情况最常见的解决方案之一就是限流，当请求达到一定的并发数或速率，就进行等待、排队、降级、拒绝服务等。

## 有哪些限流算法？

### 1、计数器限流

计数器限流算法是最为简单粗暴的解决方案，主要用来限制总并发数，比如数据库连接池大小、线程池大小、接口访问并发数等都是使用计数器算法。

如：使用 AomicInteger 来进行统计当前正在并发执行的次数，如果超过域值就直接拒绝请求，提示系统繁忙。

### 2、固定窗口限流算法

首先维护一个计数器，将单位时间段当做一个窗口，计数器记录这个窗口接收请求的次数。

当次数少于限流阀值，就允许访问，并且计数器+1
当次数大于限流阀值，就拒绝访问。
当前的时间窗口过去之后，计数器清零。

假设单位时间是1秒，限流阀值为3。在单位时间1秒内，每来一个请求,计数器就加1，如果计数器累加的次数超过限流阀值3，后续的请求全部拒绝。等到1s结束后，计数器清0，重新开始计数。如下图：

![123](https://file.wety.site/PicGo/2023/04/30974129823f47c591825414c75dc8df~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image.png)

但是，这种算法有一个很明显的临界问题：假设限流阀值为5个请求，单位时间窗口是1s,如果我们在单位时间内的前0.8-1s和1-1.2s，分别并发5个请求。虽然都没有超过阀值，但是如果算0.8-1.2s,则并发数高达10，已经超过单位时间1s不超过5阀值的定义啦。

![123](https://file.wety.site/PicGo/2023/04/2115b13f95cc4a7488f3a04a42cfc38a~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image.png)

### 3、滑动窗口限流算法

滑动窗口限流解决固定窗口临界值的问题。它将单位时间周期分为n个小周期，分别记录每个小周期内接口的访问次数，并且根据时间滑动删除过期的小周期。

![123](https://file.wety.site/PicGo/2023/04/b46a1b76b6e04ff7b240291b1fe538cc~tplv-k3u1fbpfcp-zoom-in-crop-mark-3024-0-0-0.image.png)

假设单位时间还是1s，滑动窗口算法把它划分为5个小周期，也就是滑动窗口（单位时间）被划分为5个小格子。每格表示0.2s。每过0.2s，时间窗口就会往右滑动一格。然后呢，每个小周期，都有自己独立的计数器，如果请求是0.83s到达的，0.8~1.0s对应的计数器就会加1。
我们来看下滑动窗口是如何解决临界问题的？
假设我们1s内的限流阀值还是5个请求，0.8~1.0s内（比如0.9s的时候）来了5个请求，落在黄色格子里。时间过了1.0s这个点之后，又来5个请求，落在紫色格子里。如果是固定窗口算法，是不会被限流的，但是滑动窗口的话，每过一个小周期，它会右移一个小格。过了1.0s这个点后，会右移一小格，当前的单位时间段是0.2~1.2s，这个区域的请求已经超过限定的5了，已触发限流啦，实际上，紫色格子的请求都被拒绝啦。
TIPS: 当滑动窗口的格子周期划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。

### 4、漏桶算法

漏桶算法思路很简单，我们把水比作是请求，漏桶比作是系统处理能力极限，水先进入到漏桶里，漏桶里的水按一定速率流出，当流出的速率小于流入的速率时，由于漏桶容量有限，后续进入的水直接溢出（拒绝请求），以此实现限流。

### 5、令牌桶算法

令牌桶算法的原理也比较简单，我们可以理解成医院的挂号看病，只有拿到号以后才可以进行诊病。

系统会维护一个令牌（token）桶，以一个恒定的速度往桶里放入令牌（token），这时如果有请求进来想要被处理，则需要先从桶里获取一个令牌（token），当桶里没有令牌（token）可取时，则该请求将被拒绝服务。令牌桶算法通过控制桶的容量、发放令牌的速率，来达到对请求的限制。

## 实操

### 分布式限流

#### Nginx

#### OpenResty

### 应用限流

#### 限流总并发/连接/请求数

对于一个应用系统来说一定会有极限并发/请求数，就是说总是有一个TPS/QPS阈值，如果超过了阈值则系统就会不响应或者响应的特别慢用户的请求，因此我们最好进行过载保护，防止大量请求涌入击垮系统。

如果使用过Tomcat，其Connector中有几个配置参数可以实现限制：
（1）acceptCount：如果Tomcat的线程都忙于响应，新来的连接就会进入队列排队，如果超出了排队的大小，则会拒绝连接。
（2）maxConnections：瞬时的最大连接数，超出的会排队等待
（3）maxThreads：Tomcat能够启用来处理请求的最大的线程数，如果请求处理量一直远远大于最大线程数则可能僵死。

#### 限流总资源数

如果有的资源是稀缺资源（数据库连接，线程），而且可能有多个系统都会去使用它，那么就需要限制应用；可以使用池化技术限制总资源数：连接池，线程池。比如分配给每个应用的数据库连接是100 ，那么本应用最多可以使用100个资源，超出了可以等待或者抛出异常。

#### 限流某个接口的总并发/请求数

如果接口可能会有突发的访问情况，但是又担心访问量太大造成崩溃，如抢购业务；这个时候就会需要限制这个接口的总并发/请求数总请求数；因为粒度比较细，可以为每个接口都设置相对应的阈值，可以使用Java中的原子类进行限流（AtomicLong）

适合对业务无损的服务或者需要过载保护的服务进行限流，如抢购业务，超出了大小要么让用户排队，要么告诉告诉用户已经没货了，对用户来说是可以接受的。而一些开放平台也会限制用户调用某个接口的试用请求量，也可以使用计数器限流的方式去实现。这种方式没有平滑的处理，是粗暴的限流，不推荐使用。

#### 限制某个接口的时间窗请求数

即第一个时间窗口内的请求数，如想限制某个接口/服务每秒/每分钟/每天的请求数/调用量。如一些基础服务会被很多其他的系统调用，比如商品详情页服务会调用基础商品服务调用，但是怕因为更新量较大将基础服务打挂，这时候我们将要对每秒/每分钟的调用量进行限速；

平滑限流某个接口的请求数：
之前的限流方式都不能很好的应对突发请求，即瞬间请求可能都被允许从而导致一些问题；因此在一些场景中需要对突发请求进行整形，整形为平均速率请求处理（如5r/s，则每隔200ms处理一个请求，平滑了速率）。这个时候有两种算法满足了我们的场景：
（1）令牌桶
（2）漏桶算法

### API限流

#### guava的RateLimiter工具类

RateLimiter是guava中concurrent包下的一个限流工具类，使用了令牌桶算法，可以限制每秒的访问次数。

| 修饰符 | 方法 | 描述 |
|:----|:----|:----|
| double | acquire() | 从RateLimiter获取一个许可，该方法会被阻塞知道获取到请求，阻塞动作，返回的double是从阻塞到获取到令牌等待的时间。 |
| double | acquire(int permits) | 从RateLimiter获取指定许可数，该方法会被阻塞知道获取到请求 |
| static | RateLimiter | create(double permitsPerSecond) | 根据指定的稳定吞吐率创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少查询）|
| static | RateLimiter | create(double permitsPerSecond, long warmupPeriod, TimeUnit unit) | 根据指定的稳定吞吐率和预热期来创建RateLimiter，这里的吞吐率是指每秒多少许可数（通常是指QPS，每秒多少个请求量），在这段预热时间内，RateLimiter每秒分配的许可数回平稳的增长知道预热期结束时达到其最大速率。（只要存在足够请求数来使其饱和）|
| double | getRate() | 返回RateLimiter配置中的稳定速率，该速率单位是每秒多少许可数 |
| void | setRate(double permitsPerSecond) | 更新RateLimite的稳定速率，参数permit是PerSecond由构造RateLimiter的工厂方法提供。 |
| String | toString() | 返回对象的字符表现形式 |
| boolean | tryAcquire() | 从RateLimiter获取许可，如果该许可在无延迟下的情况下立即获取得到的话 |
| boolean | tryAcquire(int permits) | 从RateLimiter获取许可数，如果该许可数可以在无延迟的情况下立即获取得到的话 |
| boolean | tryAcquire(int permits, long timeout, TimeUnit unit) | 从RateLimiter获取指定许可数如果该许可数可以在不超过timeout的时间内获取得到的话，或者如果无法在timeout过期之前获取得到许可数的话，那么立即返回false（无需等待） |
| boolean | tryAcquire(long timeout, TimeUnit unit) | 从RateLimiter获取许可如果该许可可以不超过timeout的时间内获取得到的话，或者如果无法在timeout过期之前获取得到许可的话，那么立即返回false（无需等待） |
